/* This file is generated by tdr. */
/* No manual modification is permitted. */

/* creation time: Tue Jun  4 14:17:59 2019 */
/* tdr version: 2.7.26, build at 20171102 */

#if defined(_WIN32) || defined(_WIN64)
#pragma warning(disable:4996)
#endif

#include "TdrTypeUtil.h"

namespace tsf4g_tdr
{


TdrError::ErrorType
TdrTypeUtil::tdrIp2Str(char* dest, size_t size, tdr_ip_t src)
{
    struct in_addr addr;

    memset(&addr, 0, sizeof(addr));
    addr.s_addr = src;

#if defined(_WIN32) || defined(_WIN64)
    tdr_cpp_snprintf(dest, size, "%u.%u.%u.%u", addr.s_net, addr.s_host, addr.s_lh, addr.s_impno);
    return TdrError::TDR_NO_ERROR;
#else
    if (NULL == inet_ntop(AF_INET, &addr, dest, size))
    {
        return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
    }
    dest[size-1] = '\0';
    return TdrError::TDR_NO_ERROR;
#endif
}

TdrError::ErrorType
TdrTypeUtil::tdrIp2Str(TdrWriteBuf& dest, tdr_ip_t src)
{
    struct in_addr addr;

    memset(&addr, 0, sizeof(addr));
    addr.s_addr = src;

#if defined(_WIN32) || defined(_WIN64)
    return dest.textize("%u.%u.%u.%u", addr.s_net, addr.s_host, addr.s_lh, addr.s_impno);
#else
    char dotIP[32];
    if (NULL == inet_ntop(AF_INET, &addr, dotIP, sizeof(dotIP)))
    {
        return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
    }
    dotIP[sizeof(dotIP)-1] = '\0';
    return dest.textize("%s", dotIP);
#endif
}

TdrError::ErrorType
TdrTypeUtil::UTC2TdrDateTime(tdr_datetime_t& dest, time_t utcTime)
{
    struct tm* pstTm;

#if defined(_WIN32) || defined(_WIN64)
    pstTm = localtime(&utcTime);
#else
    struct tm stTm;
    memset(&stTm, 0, sizeof(stTm));
    pstTm = localtime_r(&utcTime, &stTm);
#endif

    if (NULL == pstTm)
    {
        return TdrError::TDR_ERR_FUNC_LOCALTIME_FAILED;
    }

    TdrDateTime tdrDateTime(*pstTm);
    if (!tdrDateTime.isValid())
    {
        return TdrError::TDR_ERR_INVALID_TDRDATETIME_VALUE;
    }

    dest = tdrDateTime;

    return TdrError::TDR_NO_ERROR;
}

TdrError::ErrorType
TdrTypeUtil::str2TdrIP(tdr_ip_t& dest, const char *pszIP)
{
    assert(NULL != pszIP);

    struct in_addr addr;

#if defined(_WIN32) || defined(_WIN64)
    addr.s_addr = inet_addr(pszIP);
    if (INADDR_NONE == addr.s_addr)
    {
        return TdrError::TDR_ERR_INVALID_TDRIP_VALUE;
    }
#else
    if (0 == inet_aton(pszIP, &addr))
    {
        return TdrError::TDR_ERR_INVALID_TDRIP_VALUE;
    }
#endif

    dest = addr.s_addr;

    return TdrError::TDR_NO_ERROR;
}

TdrError::ErrorType
TdrTypeUtil::str2TdrTime(tdr_time_t& dest, const char *pszTime)
{
    assert(NULL != pszTime);

    struct tm stTm;
    memset(&stTm, 0, sizeof(stTm));
    if (NULL == tdr_pal_strptime(pszTime, "%H:%M:%S", &stTm))
    {
        return TdrError::TDR_ERR_INVALID_TDRTIME_VALUE;
    }

    TdrTime tdrTime(stTm);
    if (!tdrTime.isValid())
    {
        return TdrError::TDR_ERR_INVALID_TDRTIME_VALUE;
    }

    dest = tdrTime;

    return TdrError::TDR_NO_ERROR;
}

TdrError::ErrorType
TdrTypeUtil::str2TdrDate(tdr_date_t& dest, const char *pszDate)
{
    assert(NULL != pszDate);

    struct tm stTm;
    memset(&stTm, 0, sizeof(stTm));
    if (NULL == tdr_pal_strptime(pszDate, "%Y-%m-%d", &stTm))
    {
        return TdrError::TDR_ERR_INVALID_TDRDATE_VALUE;
    }

    TdrDate tdrDate(stTm);
    if (!tdrDate.isValid())
    {
        return TdrError::TDR_ERR_INVALID_TDRDATE_VALUE;
    }

    dest = tdrDate;

    return TdrError::TDR_NO_ERROR;
}

TdrError::ErrorType
TdrTypeUtil::str2TdrDateTime(tdr_datetime_t& dest, const char *pszDateTime)
{
    assert(NULL != pszDateTime);

    struct tm stTm;
    memset(&stTm, 0, sizeof(stTm));
    if (NULL == tdr_pal_strptime(pszDateTime, "%Y-%m-%d %H:%M:%S", &stTm))
    {
        return TdrError::TDR_ERR_INVALID_TDRDATETIME_VALUE;
    }

    TdrDateTime tdrDateTime(stTm);
    if (!tdrDateTime.isValid())
    {
        return TdrError::TDR_ERR_INVALID_TDRDATETIME_VALUE;
    }

    dest = tdrDateTime;

    return TdrError::TDR_NO_ERROR;
}

TdrError::ErrorType
TdrTypeUtil::tdrDateTime2UTC(time_t& dest, tdr_datetime_t src)
{
    struct tm stTm;
    memset(&stTm, 0, sizeof(stTm));

    TdrDateTime tdrDateTime(src);
    if (!tdrDateTime.isValid())
    {
        return TdrError::TDR_ERR_INVALID_TDRDATETIME_VALUE;
    }

    tdrDateTime.toTm(stTm);
    time_t utcTime = mktime(&stTm);
    if (-1 == utcTime)
    {
        return TdrError::TDR_ERR_INVALID_TDRDATETIME_VALUE;
    } else
    {
        dest = utcTime;
    }

    return TdrError::TDR_NO_ERROR;
}

int TdrTypeUtil::compareTdrTime(tdr_time_t left, tdr_time_t right)
{
    if (TdrTime(left) < TdrTime(right))
    {
        return -1;
    } else if (TdrTime(right) < TdrTime(left))
    {
        return 1;
    } else
    {
        return 0;
    }
}

int TdrTypeUtil::compareTdrDate(tdr_date_t left, tdr_date_t right)
{
    if (TdrDate(left) < TdrDate(right))
    {
        return -1;
    } else if (TdrDate(right) < TdrDate(left))
    {
        return 1;
    } else
    {
        return 0;
    }
}

int TdrTypeUtil::compareTdrDateTime(tdr_datetime_t left, tdr_datetime_t right)
{
    if (TdrDateTime(left) < TdrDateTime(right))
    {
        return -1;
    } else if (TdrDateTime(right) < TdrDateTime(left))
    {
        return 1;
    } else
    {
        return 0;
    }
}

size_t TdrTypeUtil::wstrlen(const tdr_wchar_t* wstr)
{
    assert(NULL != wstr);

    size_t len = 0;
    while (*wstr != (tdr_wchar_t)0)
    {
        wstr++;
        len++;
    }

    return len;
}

}
